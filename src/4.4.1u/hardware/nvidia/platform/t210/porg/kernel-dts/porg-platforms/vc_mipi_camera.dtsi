/*
 * Copyright (c) 2018-2019, NVIDIA CORPORATION.  All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#define NUM_LANES       2   /* CCC - imx327c.dtsi - number of lanes: 2 or 4 */

#include <dt-bindings/media/camera.h>
#include <dt-bindings/platform/t210/t210.h>

#define CAM1_PWDN       TEGRA_GPIO(S, 7)
#define CAM2_PWDN       TEGRA_GPIO(T, 0)
#define CAM_I2C_MUX TEGRA_GPIO(I, 0) // NFC_EN GPIO


/ {
    host1x {
        vi_base: vi {
            num-channels = <2>;
            ports {
                #address-cells = <1>;
                #size-cells = <0>;
                vi_port0: port@0 {
                    reg = <0>;
                    rbpcv2_imx327c_vi_in0: endpoint {
                        port-index = <0>;
                        bus-width = <NUM_LANES>;
                        remote-endpoint = <&rbpcv2_imx327c_csi_out0>;
                    };
                };
                vi_port1: port@1 {
                    reg = <1>;
                    rbpcv2_imx327c_vi_in1: endpoint {
                        port-index = <4>;
                        bus-width = <NUM_LANES>;
                        remote-endpoint = <&rbpcv2_imx327c_csi_out1>;
                    };
                };
            };
        };

        csi_base: nvcsi {
            num-channels = <2>;
            #address-cells = <1>;
            #size-cells = <0>;
            csi_chan0: channel@0 {
                reg = <0>;
                ports {
                    #address-cells = <1>;
                    #size-cells = <0>;
                    csi_chan0_port0: port@0 {
                        reg = <0>;
                        rbpcv2_imx327c_csi_in0: endpoint@0 {
                            port-index = <0>;
                            bus-width = <NUM_LANES>;
                            remote-endpoint = <&rbpcv2_imx327c_dual_out0>;
                        };
                    };
                    csi_chan0_port1: port@1 {
                        reg = <1>;
                        rbpcv2_imx327c_csi_out0: endpoint@1 {
                            remote-endpoint = <&rbpcv2_imx327c_vi_in0>;
                        };
                    };
                };
            };
            csi_chan1: channel@1 {
                reg = <1>;
                ports {
                    #address-cells = <1>;
                    #size-cells = <0>;
                    csi_chan1_port0: port@2 {
                        reg = <0>;
                        rbpcv2_imx327c_csi_in1: endpoint@2 {
                            port-index = <4>;
                            bus-width = <NUM_LANES>;
                            remote-endpoint = <&rbpcv2_imx327c_out1>;
                        };
                    };
                    csi_chan1_port1: port@3 {
                        reg = <1>;
                        rbpcv2_imx327c_csi_out1: endpoint@3 {
                            remote-endpoint = <&rbpcv2_imx327c_vi_in1>;
                        };
                    };
                };
            };
        };
    };

    cam_i2cmux {
        i2c_0: i2c@0 {
            imx327c_cam0: rbpcv2_imx327c_a@1a {
                compatible = "nvidia,imx327c";
                /* I2C device address */
                reg = <0x1a>;

                ports {
                    #address-cells = <1>;
                    #size-cells = <0>;

                    port@0 {
                        reg = <0>;
                        rbpcv2_imx327c_dual_out0: endpoint {
                            port-index = <0>;
                            bus-width = <NUM_LANES>;
                            remote-endpoint = <&rbpcv2_imx327c_csi_in0>;
                        };
                    };
                };
            };
        };
        i2c_1: i2c@1 {
            imx327c_cam1: rbpcv2_imx327c_e@1a {
                compatible = "nvidia,imx327c";
                /* I2C device address */
                reg = <0x1a>;

                ports {
                    #address-cells = <1>;
                    #size-cells = <0>;

                    port@0 {
                        reg = <0>;
                        rbpcv2_imx327c_out1: endpoint {
                            port-index = <4>;
                            bus-width = <NUM_LANES>;
                            remote-endpoint = <&rbpcv2_imx327c_csi_in1>;
                        };
                    };
                };
            };
        };
    };

    lens_imx327c@RBPCV2 {
        min_focus_distance = "0.0";
        hyper_focal = "0.0";
        focal_length = "3.04";
        f_number = "2.0";
        aperture = "0.0";
    };
};

/ {
    tcp: tegra-camera-platform {
        compatible = "nvidia, tegra-camera-platform";

        /**
        * Physical settings to calculate max ISO BW
        *
        * num_csi_lanes = <>;
        * Total number of CSI lanes when all cameras are active
        *
        * max_lane_speed = <>;
        * Max lane speed in Kbit/s
        *
        * min_bits_per_pixel = <>;
        * Min bits per pixel
        *
        * vi_peak_byte_per_pixel = <>;
        * Max byte per pixel for the VI ISO case
        *
        * vi_bw_margin_pct = <>;
        * Vi bandwidth margin in percentage
        *
        * max_pixel_rate = <>;
        * Max pixel rate in Kpixel/s for the ISP ISO case
        *
        * isp_peak_byte_per_pixel = <>;
        * Max byte per pixel for the ISP ISO case
        *
        * isp_bw_margin_pct = <>;
        * Isp bandwidth margin in percentage
        */
        num_csi_lanes = <4>;
        max_lane_speed = <1500000>;
        min_bits_per_pixel = <10>;
        vi_peak_byte_per_pixel = <2>;
        vi_bw_margin_pct = <25>;
        max_pixel_rate = <240000>;
        isp_peak_byte_per_pixel = <5>;
        isp_bw_margin_pct = <25>;

        /**
         * The general guideline for naming badge_info contains 3 parts, and is as follows,
         * The first part is the camera_board_id for the module; if the module is in a FFD
         * platform, then use the platform name for this part.
         * The second part contains the position of the module, ex. "rear" or "front".
         * The third part contains the last 6 characters of a part number which is found
         * in the module's specsheet from the vendor.
         */
        modules {
            cam_module0: module0 {
                badge = "porg_front_RBPCV2";
                position = "front";
                orientation = "1";
                cam_module0_drivernode0: drivernode0 {
                    pcl_id = "v4l2_sensor";
                    devname = "imx327c 7-001a";
                    proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/rbpcv2_imx327c_a@1a";
                };
                cam_module0_drivernode1: drivernode1 {
                    pcl_id = "v4l2_lens";
                    proc-device-tree = "/proc/device-tree/lens_imx327c@RBPCV2/";
                };
            };
            cam_module1: module1 {
                badge = "porg_rear_RBPCV2";
                position = "rear";
                orientation = "1";
                cam_module1_drivernode0: drivernode0 {
                    pcl_id = "v4l2_sensor";
                    devname = "imx327c 8-001a";
                    proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/rbpcv2_imx327c_e@1a";
                };
                cam_module1_drivernode1: drivernode1 {
                    pcl_id = "v4l2_lens";
                    proc-device-tree = "/proc/device-tree/lens_imx327c@RBPCV2/";
                };
            };
        };
    };
};

/ {
    cam_i2cmux {
        compatible = "i2c-mux-gpio";
        #address-cells = <1>;
        #size-cells = <0>;
        mux-gpios = <&gpio CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
        i2c-parent = <&i2c7>;
        status = "disabled";
        i2c@0 {
            status = "disabled";
            reg = <0>;
            #address-cells = <1>;
            #size-cells = <0>;
            rbpcv2_imx327c_a@1a {
                status = "disabled";
                reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
            };
        };
        i2c@1 {
            status = "disabled";
            reg = <1>;
            #address-cells = <1>;
            #size-cells = <0>;
            rbpcv2_imx327c_e@1a {
                status = "disabled";
                reset-gpios = <&gpio CAM2_PWDN GPIO_ACTIVE_HIGH>;
            };
        };
    };

    gpio@6000d000 {
        camera-control-output-low {
            gpio-hog;
            output-low;
            gpios = < CAM1_PWDN 0  CAM2_PWDN 0>;
            label = "cam1-pwdn", "cam2-pwdn";
        };
    };
};